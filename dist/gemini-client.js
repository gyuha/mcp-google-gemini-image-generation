import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';
import fs from 'fs-extra';
import path from 'path';
import { saveBase64Image, generateUniqueFilename } from './image-utils.js';
// Load environment variables from .env and .env.local
dotenv.config();
// Check if .env.local exists and load it (will override .env values)
const envLocalPath = path.resolve(process.cwd(), '.env.local');
if (fs.existsSync(envLocalPath)) {
    const envLocal = dotenv.parse(fs.readFileSync(envLocalPath));
    for (const key in envLocal) {
        process.env[key] = envLocal[key];
    }
}
// Get API key from environment variables
const API_KEY = process.env.GOOGLE_API_KEY;
// Default output directory
const DEFAULT_OUTPUT_DIR = process.env.DEFAULT_OUTPUT_DIR || './generated-images';
/**
 * Generates an image using Google's Gemini API
 */
export async function generateImage(prompt, model = 'gemini-2.0-flash-001', width = 1024, height = 1024, outputDir = DEFAULT_OUTPUT_DIR) {
    try {
        const API_KEY = process.env.GOOGLE_API_KEY;
        if (!API_KEY) {
            throw new Error('GOOGLE_API_KEY is not set in environment variables');
        }
        console.log(`Generating image with prompt: "${prompt}"`);
        console.log(`Using model: ${model}, dimensions: ${width}x${height}`);
        // Initialize the Gemini API client
        const genAI = new GoogleGenerativeAI(API_KEY);
        // Create a dedicated image generation model (Gemini Pro Vision or Flash model)
        const imageModel = genAI.getGenerativeModel({
            model: model,
        });
        // For image generation, we need to use a specific approach
        const prompt_with_dimensions = `Create an image: ${prompt}. Image dimensions should be ${width}x${height}.`;
        console.log(`Sending image generation request with prompt: "${prompt_with_dimensions}"`);
        // Using the text-to-image capability of Gemini
        const result = await imageModel.generateContentStream({
            contents: [{
                    role: 'user',
                    parts: [{ text: prompt_with_dimensions }]
                }],
            // Don't specify any MIME type or generation config that would cause problems
        });
        // Collect and process the response
        let image = null;
        let mimeType = null;
        // Process the streaming response
        for await (const chunk of result.stream) {
            const chunkText = chunk.text();
            // If we find image data in the response
            const parts = chunk?.candidates?.[0]?.content?.parts || [];
            for (const part of parts) {
                if (part.inlineData && part.inlineData.mimeType.startsWith('image/')) {
                    image = part.inlineData.data;
                    mimeType = part.inlineData.mimeType;
                    break;
                }
            }
        }
        // Complete the generation
        const response = await result.response;
        // If we haven't found an image in the streaming response, look in the final response
        if (!image) {
            const parts = response?.candidates?.[0]?.content?.parts || [];
            for (const part of parts) {
                if (part.inlineData && part.inlineData.mimeType.startsWith('image/')) {
                    image = part.inlineData.data;
                    mimeType = part.inlineData.mimeType;
                    break;
                }
            }
        }
        if (!image) {
            throw new Error('No image data was generated by Gemini API');
        }
        // Save the image
        const filename = generateUniqueFilename(prompt);
        const imagePath = saveBase64Image(image, outputDir, filename);
        return {
            success: true,
            imagePath
        };
    }
    catch (error) {
        console.error('Error generating image:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
